-- scope typing
fun f(a) {
  a.string
}

fun g(b) {
  1 - b
}

-- scope 1
{
  -- здесь проверка, что функцию можно так использовать
  f :: Int ~> Str;
  g :: Int ~> Int;

  -- f(g(Double(0), 1));
  f(g(0)) -- здесь проверка, что функция исопльзована корректно
  -- более того, если в Runtime передадут не 0, а "Hello World", то должно быть соответствующее сообщение об ошибке
};



-- scope 2

{
  f :: Double(Int) ~> Str;
  g :: Double(Int) ~> Double(Int);


  -- f(g(0)); -- не пройдёт проверку типов, как в скоупе выше
  f(g(Double(0))) -- назначили другие типы в другом скоупе

  ;
  -- scope nested
  {
    -- нужна ли проверка консистентности используемых типов в вышестоящем скоупе?
    f :: [Int] ~> Int;
    g :: Str ~> [Int];

    f(g("hello, world"))
  }
};

-- scope 3 -- no typing
{
  f(g(0)); -- не пройдёт проверку типов, как в скоупе выше
  f(g(Double(0))) -- назначили другие типы в другом скоупе
}
