-- scope typing
fun f(a) {
  a.string
}

fun g(b) {
  1 - b
}

-- scope 1
{
  -- здесь проверка, что функцию можно так использовать
  f :: Int -> Str;
  g :: Int -> Int;

  f(g(0)) -- здесь проверка, что функция использована корректно
  -- более того, если в Runtime передадут не 0, а "Hello World", то должно быть соответствующее сообщение об ошибке
  -- f(g(Double(0), 1)) -- а это не протипизируется
};



-- scope 2
{
  f :: Double(Int) -> Str;
  g :: ? -> Int;

  f(Double(g(0))) -- назначили другие типы в другом скоупе
  ;
  -- scope nested
  {
    -- нужна ли проверка консистентности используемых типов в вышестоящем скоупе?
    -- Ответ: остаётся с вышестоящим скоупом, не смотря на то, что определение на два скоупа выше
    -- f :: [Int] -> Str; -- should fail

    -- однако можно схитрить так:
    {
      -- объявляем f полностью динамического типа
      f :: ?;
      {
        f :: [Int] -> Str;
        f([g(5)])
      }
    }
  }
};

-- scope 3 -- no typing
{
  f(g(0)); -- OK
  f(Double(g(0))) -- OK
}
