-- scope typing
fun f(a) {
  a.string
}

fun g(b) {
  1 - b
}

-- scope 1
{
  -- здесь проверка, что функцию можно так использовать
  f :: Int -> Str;
  g :: Int -> Int;

  f(g(0)) -- здесь проверка, что функция использована корректно
  -- более того, если в Runtime передадут не 0, а "Hello World", то должно быть соответствующее сообщение об ошибке
  -- f(g(Double(0), 1)) -- а это не протипизируется
};



-- scope 2
{
  f :: Double(Int) -> Str;
  g :: ? -> Int;

  f(Double(g(0))) -- назначили другие типы в другом скоупе
  ;
  -- scope nested
  {
    -- нужна ли проверка консистентности используемых типов в вышестоящем скоупе? Ответ: скорее всего, только с самым верхним видимым определением
    f :: [Int] -> Str; -- should pass, but now fails :(

    f([g(5)])
  }
};

-- scope 3 -- no typing
{
  f(g(0)); -- OK
  f(g(Double(0))) -- OK
}
